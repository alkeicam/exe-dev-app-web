/**
 * @typedef GrmModal
 * @property {GrmForm} form,
 * @property {boolean} active
 * 
 * @typedef GrmForm
 * @property {GrmSection[]} sections
 * @property {boolean} visible
 * 
 * @typedef GrmSection
 * @property {string} section_name 
 * @property {GrmProp[]} props props 
 * 
 * @typedef GrmProp
 * @property {boolean} visible
 * @property {boolean} editable
 */


(function(){
    /**
 * Represents a single field described by grm meetadata provided as prop property on component.
 * Depending on type of the metadata appropriate fied is presented.
 * 
 * @param {GrmProp} prop
 * @param {GrmProp[]} props for rule handling
 * @param {boolean} editable     
 */
rivets.components['prop'] = {
    // Return the template for the component.
    template: function() {

const template = `        
        <fieldset rv-disabled="model.editable | or model.prop.editable | eq false">             
            <!-- {prop.datatype} -->
            <prop-string prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'string'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-string>
            <prop-boolean prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'boolean'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-boolean>
            <prop-integer prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'integer'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-integer>
            <prop-integer prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'int'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-integer>
            <prop-number prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'number'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-number>
            <prop-textarea prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'textarea'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-textarea>
            <prop-array prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'array'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-array>
            <prop-date prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'date'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-date>
            <prop-point prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'point'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-point>
            <prop-reference prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'reference'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-reference>
            <prop-autogenerated prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'autogenerated'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-autogenerated>
            <prop-browseable prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'browseable'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-browseable>
            <prop-textqr prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'textqr'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-textqr>                
            <prop-branches prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'branch'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-branches>
            <prop-checkbox prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'checkbox'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-checkbox>
            <prop-tags prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'tags'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-tags>
            <prop-file prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'file'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-file>
            <prop-sign prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'sign'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-sign>
            <prop-table prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'table'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-table>
            <prop-checkbox-list prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'checkbox-list'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-checkbox-list>                                                                
            <prop-password prop="model.prop" props="model.props" auth="model.auth" rv-if="model.prop.datatype | eqCI 'password'" rv-uname="model.prop.unique_name" rv-tid="model.prop.type_id" rv-mid="model.prop.metadata_id"></prop-password>
        </fieldset>        
    </div> 
    
</div>      
`
        return template;
    },        
    // 
    initialize: function(el, data) {  
        const controller = {
            model: {
                prop: data.prop,
                editable: data.editable,
                props: data.props,
                auth: data.auth                    
            }
        }
        return controller;                                                                          
    }
  }
    rivets.components['prop-boolean'] = {
        // Return the template for the component.
        template: function() {
          const template = `
    <div class="field">        
        <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
        <div class="control" rv-unless="model.prop.editable | eq false">        
            <label class="radio">
                <input type="radio" rv-name="model.prop.unique_name" value="true" rv-checked="model.prop.value" rv-on-change="handleOnChange">
                Yes
            </label>
            <label class="radio">
                <input type="radio" rv-name="model.prop.unique_name" value="false" rv-checked="model.prop.value" rv-on-change="handleOnChange">
                No
            </label>
        </div>
        <div class="control" rv-unless="model.prop.editable">        
            <input class="input" type="text" placeholder="" rv-value="model.prop.value" disabled>            
        </div>
        <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
    </div>   
    `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller = {
                model: {
                    prop: data.prop,
                    props: data.props,
                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && this.model.prop.value==undefined){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }
                    
                    return valid;
                },
                handleOnChange: async function(e,that){                
                    that.model.prop.value = e.target.value                
                    that.validate();
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }
                }
                
            }
            data.prop.validate = controller.validate.bind(controller);
            return controller;
        }
    }
    rivets.components['prop-string'] = {
        // Return the template for the component.
        template: function() {
          const template = `
    <div class="field">        
        <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
        <div class="control has-icons-right">
            <input class="input" type="text" rv-placeholder="model.prop.placeholder" rv-value="model.prop.value" rv-on-change="handleOnChange" rv-on-blur="handleOnChange" rv-class-is-danger="model.error.message | notEmpty">        
            <span class="icon is-small is-right is-hidden" rv-class-is-hidden="model.error.message | empty">
                <i class="fas fa-exclamation-triangle"></i>
            </span>
        </div>
        <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
    </div>      
    `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller =  {
                model: {
                    prop: data.prop,
                    props: data.props, // for rule working
                    mode: data.mode,

                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value || this.model.prop.value.length==0)){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }
                    if(this.model.prop.pattern){
                        try{
                            const re = new RegExp(this.model.prop.pattern, "g");
                            if(!re.test(this.model.prop.value)){
                                this.model.error.message = this.model.prop.pattern_message?this.model.prop.pattern_message:`${this.model.prop.label} invalid format`;  
                                valid = false;
                            }
                                
                        }
                        catch(error){
                            console.log(`Invalid pattern format for ${this.model.prop.unique_name}`);
                        }                    
                    }
                    return valid;
                },

                handleOnChange: async function(e,that){
                    that.validate();
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }
                }
            }            
            data.prop.validate = controller.validate.bind(controller)
            return controller;
        }
    }
    rivets.components['prop-password'] = {
        // Return the template for the component.
        template: function() {
          const template = `
    <div class="field">        
        <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
        <div class="control has-icons-right">
            <input class="input" type="password" rv-value="model.prop.value" rv-on-change="handleOnChange" rv-on-blur="handleOnChange" rv-class-is-danger="model.error.message | notEmpty">        
            <span class="icon is-small is-right is-hidden" rv-class-is-hidden="model.error.message | empty">
                <i class="fas fa-exclamation-triangle"></i>
            </span>
        </div>
        <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
    </div>      
    `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller =  {
                model: {
                    prop: data.prop,
                    props: data.props, // for rule working
                    mode: data.mode,

                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value || this.model.prop.value.length==0)){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }
                    if(this.model.prop.pattern){
                        try{
                            const re = new RegExp(this.model.prop.pattern, "g");
                            if(!re.test(this.model.prop.value)){
                                this.model.error.message = this.model.prop.pattern_message?this.model.prop.pattern_message:`${this.model.prop.label} invalid format`;  
                                valid = false;
                            }
                                
                        }
                        catch(error){
                            console.log(`Invalid pattern format for ${this.model.prop.unique_name}`);
                        }                    
                    }
                    return valid;
                },

                handleOnChange: async function(e,that){
                    that.validate();
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }
                }
            }            
            data.prop.validate = controller.validate.bind(controller)
            return controller;
        }
    }
    
    rivets.components['prop-date'] = {
        // Return the template for the component.
        template: function() {
          const template = `
    <div class="field">    
        <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
        <div class="control has-icons-right">
            
            <!-- <input readonly class="input" rv-name="model.prop.unique_name | prefix 'date-'" type="text" rv-placeholder="model.prop.placeholder" rv-value="model.prop.displayValue" rv-on-blur="handleOnChangeManual" rv-on-change="handleOnChangeManual" rv-class-is-danger="model.error.message | notEmpty">        -->

            <input readonly class="input" type="text" rv-value="model.prop.display_value" rv-class-is-danger="model.error.message | notEmpty">
            <span class="icon is-small is-right is-hidden" rv-class-is-hidden="model.error.message | empty">
                <i class="fas fa-exclamation-triangle"></i>
            </span>
        </div>
        <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
    </div>      
    `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller = {
                model: {
                    prop: data.prop,
                    props: data.props,
                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value)){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }                    
                    return valid;
                },                
                handleOnChange: async function(selectedDates, dateStr, instance){
                    let that = this;
                    this.model.prop.display_value = dateStr;
                    this.model.prop.value = selectedDates[0].getTime();
    
                    
                    
    
                    that.validate()
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }    
                      
                }
            }
            // setup calendar controll
            const elem = el.querySelector(`input`);
            const picker = flatpickr(elem, {
                enableTime: true,
                onChange: controller.handleOnChange.bind(controller),
                dateFormat: "Y-m-d H:i",
                time_24hr: true,
                defaultDate: controller.model.prop.display_value
            })
            // const datepicker = new Datepicker(elem, {
            //     format: "yyyy-mm-dd"
            // });
    
            // elem.addEventListener("changeDate",controller.handleOnChange.bind(controller));
    
            // data.prop.validate = controller.validate.bind(controller);
            return controller;
        }
    }
    
    
    
    rivets.components['prop-textarea'] = {
        // Return the template for the component.
        template: function() {
          const template = `
    <div class="field">
        <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
        <div class="control has-icons-right">
            <textarea class="textarea is-size-7" rv-placeholder="model.prop.placeholder" rv-value="model.prop.value" rv-on-change="handleOnChange" rv-on-blur="handleOnChange" rv-class-is-danger="model.error.message | notEmpty"></textarea>        
            <span class="icon is-small is-right is-hidden" rv-class-is-hidden="model.error.message | empty">
                <i class="fas fa-exclamation-triangle"></i>
            </span>
        </div>
        <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
    </div>      
    `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller = {
                model: {
                    prop: data.prop,
                    props: data.props,
                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value || this.model.prop.value.length==0)){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }
                    if(this.model.prop.pattern){
                        try{
                            const re = new RegExp(this.model.prop.pattern, "g");
                            if(!re.test(this.model.prop.value)){
                                this.model.error.message = this.model.prop.pattern_message?this.model.prop.pattern_message:`${this.model.prop.label} invalid format`;  
                                valid = false;
                            }
                                
                        }
                        catch(error){
                            console.log(`Invalid pattern format for ${this.model.prop.unique_name}`);
                        }                    
                    }
                    return valid;
                },
                handleOnChange: async function(e,that){
                    that.validate();
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }
                }
            }
            data.prop.validate = controller.validate.bind(controller);
            return controller;
        }
    }
    rivets.components['prop-integer'] = {
        // Return the template for the component.
        template: function() {
          const template = `
    <div class="field">
        <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
        <div class="control has-icons-right">
            <input class="input" type="number" rv-placeholder="model.prop.placeholder" rv-value="model.prop.value" rv-on-change="handleOnChange" rv-on-blur="handleOnChange" rv-class-is-danger="model.error.message | notEmpty">        
            <span class="icon is-small is-right is-hidden" rv-class-is-hidden="model.error.message | empty">
                <i class="fas fa-exclamation-triangle"></i>
            </span>
        </div>
        <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
    </div>      
    `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller =  {
                model: {
                    prop: data.prop,
                    props: data.props,
                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value || this.model.prop.value.length==0)){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }
                    if(this.model.prop.pattern){
                        try{
                            const re = new RegExp(this.model.prop.pattern, "g");
                            if(!re.test(this.model.prop.value)){
                                this.model.error.message = this.model.prop.pattern_message?this.model.prop.pattern_message:`${this.model.prop.label} invalid format`;  
                                valid = false;
                            }
                                
                        }
                        catch(error){
                            console.log(`Invalid pattern format for ${this.model.prop.unique_name}`);
                        }                    
                    }
                    return valid;
                },
                handleOnChange: async function(e,that){
                    that.validate()
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }                
                }
            }
            data.prop.validate = controller.validate.bind(controller);
            return controller;
        }
    }
    rivets.components['prop-number'] = {
        // Return the template for the component.
        template: function() {
          const template = `
    <div class="field">
        <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
        <div class="control has-icons-right">
            <input class="input" type="number" rv-placeholder="model.prop.placeholder" rv-value="model.prop.value" rv-on-change="handleOnChange" rv-on-blur="handleOnChange" rv-class-is-danger="model.error.message | notEmpty">        
            <span class="icon is-small is-right is-hidden" rv-class-is-hidden="model.error.message | empty">
                <i class="fas fa-exclamation-triangle"></i>
            </span>
        </div>
        <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
    </div>      
    `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller =  {
                model: {
                    prop: data.prop,
                    props: data.props,
                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value || this.model.prop.value.length==0)){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }
                    if(this.model.prop.pattern){
                        try{
                            const re = new RegExp(this.model.prop.pattern, "g");
                            if(!re.test(this.model.prop.value)){
                                this.model.error.message = this.model.prop.pattern_message?this.model.prop.pattern_message:`${this.model.prop.label} invalid format`;  
                                valid = false;
                            }
                                
                        }
                        catch(error){
                            console.log(`Invalid pattern format for ${this.model.prop.unique_name}`);
                        }                    
                    }
                    return valid;
                },
                handleOnChange: async function(e,that){
                    that.validate()
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }                
                }
            }
            data.prop.validate = controller.validate.bind(controller);
            return controller;
        }
    }
    rivets.components['prop-array'] = {
        // Return the template for the component.
        template: function() {
          const template = `
            <div class="field">
                <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
                <div class="control">
                    <div class="select">
                        <select rv-on-change="handleOnChange" rv-on-blur="handleOnChange" rv-value="model.prop.value">                       
                            <option value="-1">------------------</option>
                            <option rv-each-option="model.prop.dict" rv-value="deriveId | call option">{deriveDisplay | call option}</option>                
                        </select>
                    </div>
                </div>
                <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
            </div>      
            `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller = {
                model: {
                    prop: data.prop,
                    props: data.props,
                    error: {
                        message: undefined
                    }                    
                },
                deriveId: function(dictItem){
                    return dictItem.id||dictItem.picklist_data_id||dictItem.value
                },
                deriveDisplay: function(dictItem){
                    return dictItem.display_value||dictItem.value
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value || this.model.prop.value == "-1")){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;               
                        valid = false;
                    }

                    return valid;
                        
                },
                handleOnChange: async function(e,that){
                    
                    that.model.prop.value = e.target.value;
                    that.validate();
                    
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        if (typeof that.model.prop.rule === 'function') {
                            await that.model.prop.rule(that.model.prop.value, that.model.props);
                        }else{
                            const AsyncFunction = async function () {}.constructor;
                            let f = new AsyncFunction('value','props', that.model.prop.rule);
                            await f(that.model.prop.value, that.model.props);
                        }
                        
                    }
                }
            }
            data.prop.validate = controller.validate.bind(controller);
            return controller;
        }
    }
    
    
    
    rivets.components['prop-point'] = {
        // Return the template for the component.
        template: function() {
          const template = `          
    <div class="field">
        <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
        <div class="control has-icons-right">
            <!-- rv-on-change="handleOnChange" rv-on-blur="handleOnChange" -->
            <input class="input" type="text" rv-placeholder="model.prop.placeholder" rv-value="model.prop.display_value"  rv-class-is-danger="model.error.message | notEmpty">        
            <span class="icon is-small is-right is-hidden" rv-class-is-hidden="model.error.message | empty">
                <i class="fas fa-exclamation-triangle"></i>
            </span>
        </div>
        <p class="help is-hidden" rv-class-is-hidden="model.prop.latlng | empty">({model.prop.latlng}) <a target="_blank" rv-href="model.prop.latlng | hrefBuilder 'https://maps.google.com/?q=@value'">See on map</a></p>
        <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
    </div>      
    `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            // (lat,lon)#pointName
            const controller = {
                model: {
                    prop: data.prop,
                    props: data.props,
                    error: {
                        message: undefined
                    },
                    searchBox: undefined
                },
                validate: function(){
                    let that = this;
                    let valid = true;
                    that.model.error.message = undefined;
                    if(that.model.prop.obligatory && (!that.model.prop.value || that.model.prop.value.length==0)){
                        that.model.error.message = `${that.model.prop.label} must not be empty`;
                        valid = false;
                    }
                        
                    return valid;
                },
                handleOnChange: async function(e,that){
                    that.validate();
                    
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }
                },
                handleOnChangeFromAddressSearch: async function(){
                    let that = this;
                    that.model.error.message = undefined;
                    const places = this.model.searchBox.getPlaces();                
                    // (lat,lon)#pointName
                    this.model.prop.value = `(${places[0].geometry.location.lat()},${places[0].geometry.location.lng()})#${places[0].formatted_address}`
                    this.model.prop.display_value = places[0].formatted_address
                    this.model.prop.latlng = `${places[0].geometry.location.lat()},${places[0].geometry.location.lng()}`  
                    if(that.model.prop.obligatory && (!that.model.prop.value || that.model.prop.value.length==0))
                        that.model.error.message = `${that.model.prop.label} must not be empty`;              

                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }
                    
                }
            }
            const input = el.querySelector(`input`);
            var searchBox = new google.maps.places.SearchBox(input, {
                // options
            });
            controller.model.searchBox = searchBox;
            searchBox.addListener("places_changed",controller.handleOnChangeFromAddressSearch.bind(controller));
    
            data.prop.validate = controller.validate.bind(controller);

            return controller
        }
    }
    
    rivets.components['prop-reference'] = {
        // Return the template for the component.
        template: function() {
          const template = `
    <div class="field mb-2">
        <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
    </div>
    <div class="field has-addons" style>
        <div class="control is-expanded">
            <input readonly type="text" class="input" rv-value="model.prop.display_value" rv-on-change="handleOnChange" rv-on-blur="handleOnChange" rv-class-is-danger="model.error.message | notEmpty">        
        </div>
        <div class="control" rv-class-is-hidden="model.prop.editable | eq false">
            <button class="button" rv-on-click="showBrowser">
                <span class="icon is-small">
                    <i class="fas fa-search"></i>
                </span>
            </button>
        </div>
    </div>
    <!-- reference search modal -->  
    <div class="modal" rv-class-is-active="model.modal.visible">
        <div class="modal-background" style="background-color: rgba(255, 255, 255, 0.96)"></div>
        <div class="modal-content">
            <nav class="panel">
                <p class="panel-heading">
                    Browser
                </p>
                <div class="panel-block">
                    <p class="control has-icons-left">
                    <input class="input" type="text" placeholder="Search">
                    <span class="icon is-left">
                        <i class="fas fa-search" aria-hidden="true"></i>
                    </span>
                    </p>
                </div>
                <a class="panel-block " rv-on-click="handleItemSelected" rv-each-entity="model.entities.list" rv-data-entity="entity.id">
                    <span class="panel-icon">
                    <i class="fas fa-book" aria-hidden="true"></i>
                    </span>
                    {entity.name}
                </a>
                
                <a class="panel-block" rv-unless="model.modal.notBusy">
                    <span class="panel-icon">
                    <i class="fas fa-spinner fa-pulse" aria-hidden="true"></i>
                    </span>
                    Loading data....                
                </a>
                <a class="panel-block" rv-if="model.entities.list | sizeLtAnd 1 model.modal.notBusy">
                    <span class="panel-icon">
                    <i class="fas fa-exclamation-triangle" aria-hidden="true"></i>
                    </span>
                    No data found. Either change search criteria or check configuration.                
                </a>
            </nav>
        </div>
        <button class="modal-close is-large" style="background-color: gray;" aria-label="close" rv-on-click="hideBrowser"></button>
    </div>    
    `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            
            const controller = {            
                model: {
                    prop: data.prop,
                    props: data.props,
                    entities: {
                        original: [],
                        list: []
                    },
                    error: {
                        message: undefined
                    },
                    modal: {
                        visible: false,
                        notBusy: true
                    }
                },
                showBrowser: function(e, that){
                    that.model.modal.visible = true;
                    that.model.modal.notBusy = false;
                    grm.AdminApi.organizationEntitiesByType(that.model.prop.tenant_id, that.model.prop.refer_type).then((entities)=>{
                        if(that.model.prop.mapping){
                            // make an object from mapping string
                            const mapper = JSON.parse(that.model.prop.mapping);
                            // make a listing function (entity)=>{id: , name: }
                            const f = new Function('entity', mapper.list);
                            // f.call(null, entity)
                            that.model.entities.original = entities.items.map(f);
                            that.model.entities.list = entities.items.map(f);
                        }else{
                            that.model.entities.original = entities.items;
                            that.model.entities.list = entities.items;                    
                        }                        
                    }).finally(()=>{
                        that.model.modal.notBusy = true;
                    })
                },
                hideBrowser: function(e, that){
                    that.model.modal.visible = false;
                },
                handleItemSelected: function(e, that){
                    const input = e.target;
                    const entityId = input.dataset.entity;
                    const entity = that.model.entities.original.find((item)=>{return item.id == entityId});
                    if(that.model.prop.mapping){
                        // make an object from mapping string
                        const mapper = JSON.parse(that.model.prop.mapping);
                        // make a display function (entity)=>string
                        const f = new Function('entity', mapper.display);

                        that.model.prop.display_value = f.call(null, entity)
                    }else{
                        that.model.prop.display_value = entity.name;
                    }                                        
                    that.model.prop.value = entity.id;
                    that.hideBrowser(e, that);
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value || this.model.prop.value.length==0)){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }                    
                    return valid;
                },
                handleOnChange: async function(e,that){
                    that.validate();
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }
                }
            }
            data.prop.validate = controller.validate.bind(controller);
            return controller;
        }
    }
    
    rivets.components['prop-autogenerated'] = {
        // Return the template for the component.
        template: function() {
          const template = `
    <div class="field">
        <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
        <div class="control has-icons-right">
            <input class="input" readonly type="text" rv-value="model.prop.default_value" >        
            <span class="icon is-small is-right is-hidden" rv-class-is-hidden="model.error.message | empty">
                <i class="fas fa-exclamation-triangle"></i>
            </span>
        </div>
        <p class="help" >{model.prop.label} is autogenerated.</p>
    </div>      
    `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            return {
                model: {
                    prop: data.prop,
                    error: {
                        message: undefined
                    }
                },
            }
        }
    }

    /**
     * @param {GrmProp} prop prop
     * @param {GrmProp[]} props section props      
     */
    rivets.components['prop-branches'] = {
        // Return the template for the component.
        template: function() {
        const template = `
            <div class="field">
                <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
                <div class="field has-addons is-hidden" rv-class-is-hidden="model._isEditMode">
                    <div class="control is-expanded">
                        <input readonly type="text" class="input" rv-value="model.prop.display_value" rv-class-is-danger="model.error.message | notEmpty">        
                    </div>
                    <div class="control" rv-class-is-hidden="model.prop.editable | eq false">
                        <button class="button" rv-on-click="handleShowBranches">
                            <span class="icon is-small">
                                <i class="fas fa-search"></i>
                            </span>
                        </button>
                    </div>
                </div>
                <div class="is-hidden" rv-class-is-hidden="model._isEditMode | eq false">
                    <grm-branches-view organization-id="model.auth.user.organization_id" click-provider="handleOnChange"></grm-branches-view>    
                </div>                
            </div>                
            <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>                
            `
            return template;
        },
    
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            
            const controller = {            
                model: {
                    prop: data.prop,
                    props: data.props,   
                    auth: data.auth, 
                    _isEditMode: false,                
                    error: {
                        message: undefined
                    }
                },
                handleShowBranches: function(e, that){
                    that.model._isEditMode = true;
                },                
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    let that = this;                    
                    if(that.model.prop.obligatory && (!that.model.prop.value || that.model.prop.value.length==0)){
                        that.model.error.message = `${that.model.prop.label} must not be empty`;
                        valid = false;
                    }
                        
                    if(that.model.prop.pattern){
                        try{
                            const re = new RegExp(that.model.prop.pattern, "g");
                            if(!re.test(that.model.prop.value)){
                                that.model.error.message = `${that.model.prop.label} invalid format`;                        
                                valid = false;
                            }
                                
                        }
                        catch(error){
                            console.log(`Invalid pattern format for ${that.model.prop.unique_name}`);
                        }                    

                    }
                    
                    return valid;
                },
                handleOnChange: function(branch){
                    this.model.prop.value = branch.group_id;
                    this.model.prop.display_value = branch.group_name;
                    this.model._isEditMode = false;

                    this.validate();
                    // process rule if validation is ok
                    if(!this.model.error.message && this.model.prop.rule){
                        const f = new Function('value','props', this.model.prop.rule);
                        f.call(null, this.model.prop.value, this.model.props)
                    }
                }
            }
            controller.handleOnChange = controller.handleOnChange.bind(controller);
            data.prop.validate = controller.validate.bind(controller);
            return controller;
        }
    }

    rivets.components['prop-checkbox'] = {
        // Return the template for the component.
        template: function() {
          const template = `
            <div class="field">
                <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
                <label class="checkbox" rv-if="model.prop.editable">
                    <input value="true" type="checkbox" rv-name="model.prop.unique_name" rv-checked="model.prop.value" rv-on-change="handleOnChange" rv-class-is-danger="model.error.message | notEmpty"/>
                    {model.prop.label} <span rv-if="model.prop.obligatory">*</span>
                </label>        
                <label class="checkbox" rv-unless="model.prop.editable">
                    <input value="true" type="checkbox" rv-name="model.prop.unique_name" rv-checked="model.prop.value" disabled/>
                    {model.prop.label} <span rv-if="model.prop.obligatory">*</span>
                </label>                        
                <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
            </div>   
        `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller = {
                model: {
                    prop: data.prop,
                    props: data.props,
                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && !this.model.prop.value){
                        this.model.error.message = `${this.model.prop.label} must be true`;                        
                        valid = false;
                    }
                    
                    return valid;
                },
                handleOnChange: function(e,that){                
                    that.model.prop.value = e.target.checked;
                    that.validate();
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const f = new Function('value','props', that.model.prop.rule);
                        f.call(null, that.model.prop.value, that.model.props)
                    }
                }                
            }
            data.prop.validate = controller.validate.bind(controller);
            return controller;
        }
    }

    rivets.components['prop-checkbox-list'] = {
        // Return the template for the component.
        template: function() {
          const template = `
            <div class="field">
                <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
                <label class="checkbox is-block" rv-each-item="model.prop.dict">
                    <input type="checkbox" rv-if="model.prop.editable" rv-name="item.id" rv-checked="item._checked" rv-on-change="handleOnChange" rv-class-is-danger="model.error.message | notEmpty"/>
                    <input rv-unless="model.prop.editable" rv-name="item.id" type="checkbox" rv-checked="item._checked" disabled/>
                    {item.value} 
                </label>
                <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
            </div>   
        `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller = {
                model: {
                    prop: data.prop,
                    props: data.props,
                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && !this.model.prop.value){
                        this.model.error.message = `${this.model.prop.label} must be true`;                        
                        valid = false;
                    }
                    
                    return valid;
                },
                handleOnChange: function(e,that){    
                    // remove just in case we unchecked
                    that.model.prop.value = that.model.prop.dict.filter(item=>item._checked).map(item=>item.id).join(",");
                    // that.model.prop.value = that.model.prop.value.split(",").filter(item=>item!=e.target.name).join(",");
                    // if(e.target.checked){
                    //     const temp = that.model.prop.value.split(",");
                    //     temp.push(e.target.name);
                    //     that.model.prop.value = temp.filter(item=>item.length>0).join(",");                        
                    // }            
                    console.log(that.model.prop.value);
                    that.validate();
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const f = new Function('value','props', that.model.prop.rule);
                        f.call(null, that.model.prop.value, that.model.props)
                    }
                }                
            }
            data.prop.validate = controller.validate.bind(controller);
            // if(controller.model.prop.value){
            //     controller.model.prop.value.split(",").forEach(item=>{
            //         const candidate = controller.model.prop.dict.find(subitem=>subitem.id == item);
            //         if(candidate) candidate._checked=true
            //     });
            // }
            return controller;
        }
    }

        /**
     * @param {GrmProp} prop prop
     * @param {GrmProp[]} props section props      
     */
    rivets.components['prop-browseable'] = {
        // Return the template for the component.
        template: function() {
            const template = `
            <div class="field mb-2">
                <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
            </div>
            <div class="field has-addons" style>
                <div class="control is-expanded">
                    <input readonly type="text" class="input" rv-value="model.prop.display_value" rv-on-change="handleOnChange" rv-on-blur="handleOnChange" rv-class-is-danger="model.error.message | notEmpty">        
                </div>
                <div class="control" rv-class-is-hidden="model.prop.editable | eq false">
                    <button class="button" rv-on-click="showBrowser">
                        <span class="icon is-small">
                            <i class="fas fa-search"></i>
                        </span>
                    </button>
                </div>
            </div>
            <!-- reference search modal -->  
            <div class="modal" rv-class-is-active="model.modal.visible">
                <div class="modal-background" style="background-color: rgba(255, 255, 255, 0.96)"></div>
                <div class="modal-content">
                    <nav class="panel">
                        <p class="panel-heading">
                            Browser
                        </p>
                        <div class="panel-block">
                            <p class="control has-icons-left">
                            <input class="input" type="text" placeholder="Hit Enter for Search" rv-value="model.entities.filter" rv-on-blur="handleFilter" rv-on-change="handleFilter">
                            <span class="icon is-left">
                                <i class="fas fa-search" aria-hidden="true"></i>
                            </span>
                            </p>
                        </div>
                        <a class="panel-block " rv-on-click="handleItemSelected" rv-each-entity="model.entities.list" rv-data-entity="entity.id">
                            <span class="panel-icon">
                            <i class="fas fa-book" aria-hidden="true"></i>
                            </span>
                            {entity.name}
                        </a>
                        
                        <a class="panel-block" rv-unless="model.modal.notBusy">
                            <span class="panel-icon">
                            <i class="fas fa-spinner fa-pulse" aria-hidden="true"></i>
                            </span>
                            Loading data....                
                        </a>
                        <a class="panel-block" rv-if="model.entities.list | sizeLtAnd 1 model.modal.notBusy">
                            <span class="panel-icon">
                            <i class="fas fa-exclamation-triangle" aria-hidden="true"></i>
                            </span>
                            No data found. Either change search criteria or check configuration.                
                        </a>
                    </nav>
                </div>
                <button class="modal-close is-large" style="background-color: gray;" aria-label="close" rv-on-click="hideBrowser"></button>
            </div>    
            `
            return template;
        },
        
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            
            const controller = {            
                model: {
                    prop: data.prop,
                    props: data.props,                    
                    entities: {
                        original: [],
                        list: [],
                        filter: ""
                    },
                    error: {
                        message: undefined
                    },
                    modal: {
                        visible: false,
                        notBusy: true
                    }
                },
                showBrowser: async function(e, that){
                    that.model.modal.visible = true;
                    that.model.modal.notBusy = false;
                    const entities = await that.model.prop._provider(that.model.prop);
                    that.model.entities.original.length = 0;
                    that.model.entities.list.length = 0;
                    entities.forEach(item=>{
                        that.model.entities.original.push(item);    
                        that.model.entities.list.push(item);
                    })
                    // that.model.entities.original = entities;
                    // that.model.entities.list = entities;                    
                    that.model.modal.notBusy = true;                    
                },
                hideBrowser: function(e, that){
                    that.model.modal.visible = false;
                },
                handleItemSelected: function(e, that){
                    const input = e.target;
                    const entityId = input.dataset.entity;
                    const entity = that.model.entities.original.find((item)=>{return item.id == entityId});
                    that.model.prop.display_value = entity.name;
                    that.model.prop.value = entity.id;
                    that.hideBrowser(e, that);
                },
                handleFilter: async function(e, that){
                    that.model.entities.list = JSON.parse(JSON.stringify(that.model.entities.original))
                    that.model.entities.list = that.model.entities.list.filter(item=>{
                        let match = false;
                        if(that.model.entities.filter.toLowerCase().startsWith("#")){
                            // search by id
                            match = that.model.idProvider(item).toLowerCase().startsWith(that.model.entities.filter.toLowerCase().substring(1))?true:false;
                        }else{
                            Object.keys(item).forEach(key=>{
                                match = JSON.stringify(item[key]).toLowerCase().includes(that.model.entities.filter.toLowerCase())?true:match;
                            })
                        }
                        
                        
                        return match;
                    });
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    let that = this;                    
                    if(that.model.prop.obligatory && (!that.model.prop.value || that.model.prop.value.length==0)){
                        that.model.error.message = `${that.model.prop.label} must not be empty`;
                        valid = false;
                    }
                        
                    if(that.model.prop.pattern){
                        try{
                            const re = new RegExp(that.model.prop.pattern, "g");
                            if(!re.test(that.model.prop.value)){
                                that.model.error.message = `${that.model.prop.label} invalid format`;                        
                                valid = false;
                            }
                                
                        }
                        catch(error){
                            console.log(`Invalid pattern format for ${that.model.prop.unique_name}`);
                        }                    
    
                    }
                    
                    return valid;
                },
                handleOnChange: function(e,that){
                    that.validate();
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const f = new Function('value','props', that.model.prop.rule);
                        f.call(null, that.model.prop.value, that.model.props)
                    }
                }
            }
            data.prop.validate = controller.validate.bind(controller);
            return controller;
        }
    }

    rivets.components['prop-tags'] = {
        // Return the template for the component.
        template: function() {
          const template = `
            <div class="field">
                <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
                <div class="control has-icons-right" rv-if="model.prop.editable">
                    <input class="input" type="text" rv-placeholder="model.prop.placeholder" rv-value="model.prop.value" rv-on-change="handleOnChange" rv-on-blur="handleOnChange" rv-class-is-danger="model.error.message | notEmpty">        
                    <span class="icon is-small is-right is-hidden" rv-class-is-hidden="model.error.message | empty">
                        <i class="fas fa-exclamation-triangle"></i>
                    </span>
                </div>
                <div class="control py-1" rv-unless="model.prop.editable">
                    <span class="tag mr-1" rv-each-item="model.prop.value | split">{item}</span>
                </div>

                <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
            </div>      
            `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller =  {
                model: {
                    prop: data.prop,
                    props: data.props, // for rule working                    
                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value || this.model.prop.value.length==0)){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }                    
                    return valid;
                },

                handleOnChange: function(e,that){
                    that.validate();
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){
                        const f = new Function('value','props', that.model.prop.rule);
                        f.call(null, that.model.prop.value, that.model.props)
                    }
                }
            }            
            data.prop.validate = controller.validate.bind(controller)
            return controller;
        }
    }

    rivets.components['prop-file'] = {
        // Return the template for the component.
        template: function() {
          const template = `
            <div class="field">
                
                <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
                <div class="file has-name is-boxed" rv-class-is-hidden="model.prop.editable | eq false" rv-x="updateDisplay | call model.prop.value model.prop">
                    <label class="file-label">
                    <input class="file-input" type="file" rv-on-change="handleOnChange"/>
                    <span class="file-cta">
                        <span class="file-icon">
                        <i class="fas fa-upload"></i>
                        </span>
                        <span class="file-label"> Choose a file… </span>
                    </span>
                    <span class="file-name" rv-class-is-hidden="model.prop.display_value | empty">{model.prop.display_value}</span>
                    </label>
                </div>
                <div class="control">
                    <input readonly type="text" class="input" rv-value="model.prop.display_value" rv-class-is-hidden="model.prop.editable">        
                </div>


                <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
            </div>      
            `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller =  {
                model: {
                    prop: data.prop,
                    props: data.props, // for rule working                    
                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value || this.model.prop.value.length==0)){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }                    
                    return valid;
                },
                updateDisplay: function(value, prop){                    
                    if(value){
                        // get filename
                        const firstPos = value.indexOf(';');
                        const fileName = value.substring(0,firstPos).replace("name:","");
                        const size = value.substring(firstPos+1,value.indexOf(';', firstPos+1)).replace("size:","");

                        prop.display_value = `${fileName} (${size} bytes)`;
                    }else{
                        prop.display_value = `Empty (0 bytes)`
                    }
                    

                },
                handleOnChange: function(e,that){
                    console.log(e.target.files);

                    if(e.target.files.length>0){
                        var fileReader = new FileReader();

                        fileReader.onloadend = () => {
                            // console.log(fileReader.result);
                            const fileData = fileReader.result;
                            // that.model.prop.display_value = `${e.target.files[0].name}`
                            const fileName = e.target.files[0].name;
                            const fileSize = e.target.files[0].size;
                            that.model.prop.value = `name:${fileName};size:${fileSize};${fileData}`
                            // Logs data:<type>;base64,wL2dvYWwgbW9yZ...
                            that.validate();
                            // process rule if validation is ok
                            if(!that.model.error.message && that.model.prop.rule){
                                const f = new Function('value','props', that.model.prop.rule);
                                f.call(null, that.model.prop.value, that.model.props)
                            }
                        };
    
                        fileReader.readAsDataURL(e.target.files[0]);
                    }else{
                        that.validate();
                        // process rule if validation is ok
                        if(!that.model.error.message && that.model.prop.rule){
                            const f = new Function('value','props', that.model.prop.rule);
                            f.call(null, that.model.prop.value, that.model.props)
                        }
                    }                                        
                }
            }            
            data.prop.validate = controller.validate.bind(controller)
            return controller;
        }
    }

    rivets.components['prop-sign'] = {
        // Return the template for the component.
        template: function() {
          const template = `
            <div class="field">
                <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
                <div class="control">
                    <canvas></canvas>
                </div>
                <div class="control">
                    <a class="button is-fullwidth" rv-on-click="handleClear">Clear</a>
                </div>
                <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
            </div>      
            `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller =  {
                model: {
                    prop: data.prop,
                    props: data.props, // for rule working                    
                    pad: undefined,
                    error: {
                        message: undefined
                    }
                },
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && (!this.model.prop.value || this.model.prop.value.length==0)){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }                    
                    return valid;
                },                
                handleClear: function(e,that){
                    that.pad.clear();
                    that.model.prop.value = undefined
                }
            }            
            data.prop.validate = controller.validate.bind(controller)

            // setup calendar controll
            const elem = el.querySelector(`canvas`);
            // uses https://github.com/szimek/signature_pad
            // https://cdn.jsdelivr.net/npm/signature_pad@4.1.7/dist/signature_pad.umd.min.js
            const signaturePad = new SignaturePad(elem, {
                backgroundColor: "rgb(245,245,245)"
            });
            controller.pad = signaturePad;
            if(controller.model.prop.value)
                controller.pad.fromDataURL(controller.model.prop.value);    
            signaturePad.addEventListener("endStroke", () => {
                const name = "signature"
                const dataSvg = signaturePad.toDataURL("image/svg+xml");
                controller.model.prop.value = dataSvg;                
              }, 
            //   { once: true }
            );    
            signaturePad.addEventListener("beginStroke", () => {
                signaturePad.clear();
                controller.model.prop.value = undefined
            }, { once: true });                                             
            return controller;
        }
    }

    rivets.components['prop-textqr'] = {
        // requires umd qr-scanner javascript in page https://www.npmjs.com/package/qr-scanner
        // Return the template for the component.
        template: function() {
          const template = `
            <div class="field">        
                <label class="label">{model.prop.label} <span rv-if="model.prop.obligatory">*</span></label>
                <div class="is-hidden" rv-class-is-hidden="model.prop.editable | eq false">
                    <video></video>
                </div>
                <div class="control" rv-unless="model.prop.editable | eq false"> 
                    <button class="button" rv-class-is-hidden="model.scanning" rv-on-click="handleScan">Scan</button>
                    <button class="button" rv-class-is-hidden="model.scanning | eq false" rv-on-click="handleCancelScan">Cancel</button>
                </div>
                <div class="control">        
                    <input class="input" type="text" placeholder="" rv-value="model.prop.value" disabled>            
                </div>
                <p class="help is-danger is-hidden" rv-class-is-hidden="model.error.message | empty">{model.error.message}</p>
            </div>   
            `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        initialize: function(el, data) {
            const controller = {
                model: {
                    prop: data.prop,
                    props: data.props, // for rules working
                    scanning: false,
                    error: {
                        message: undefined
                    }
                },
                scanner: undefined,                
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && !this.model.prop.value){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }
                    
                    return valid;
                },
                handleScan: function(e,that){
                    that.model.scanning = true;
                    that.scanner.start();
                },
                handleCancelScan: function(e,that){
                    that.scanner.stop();
                    that.model.scanning = false;
                },
                handleScanResult: function(result){
                    console.log("Scan result", result);
                    this.handleOnChange({target:{value:result.data}},this)
                },
                handleOnChange: async function(e,that){                
                    that.model.prop.value = e.target.value                
                    that.validate();
                    // process rule if validation is ok
                    if(!that.model.error.message && that.model.prop.rule){                        
                        const AsyncFunction = async function () {}.constructor;
                        let f = new AsyncFunction('value','props', that.model.prop.rule);
                        await f(that.model.prop.value, that.model.props);
                    }
                }
                
            }
            data.prop.validate = controller.validate.bind(controller);

            const videoElem = el.getElementsByTagName("video")[0];
            const qrScanner = new QrScanner(
                videoElem,
                controller.handleScanResult.bind(controller),
                {returnDetailedScanResult: true},
            );
            controller.scanner = qrScanner
            return controller;
        }
    }

    rivets.components['prop-table'] = {
        // Return the template for the component.
        template: function() {
          const template = `                               
                                    
            <!-- search and navigate bar -->
            <div class="box">
                <!-- Main container -->
                <nav class="level">
                    <!-- Left side -->
                    <div class="level-left">                        
                        <div class="level-item">
                            <div class="field has-addons">
                            <p class="control">
                                <input class="input" type="text" placeholder="Find an item" rv-value="model._entities.filter">
                            </p>
                            <p class="control">
                                <button class="button" rv-on-click="handleSearch">
                                Search
                                </button>
                            </p>
                            </div>
                        </div>
                    </div>

                    <!-- Right side -->
                    <div class="level-right">                        
                    </div>
                </nav>            
            </div>
            <div class="table-container">  
                <table class="table mt-6 is-fullwidth" >
                    <thead>
                        <tr>                        
                        <th rv-each-item="model._columns" >{item.label}</th>
                        </tr>
                    </thead>                    
                    <tbody rv-if="model.prop.editable" rv-data-x="reload | call model model.prop.columns model.prop.rows">                    
                        <!-- is-selected -->
                        <tr rv-each-row="model._entities.list">                                                
                            <td rv-each-col="model._columns" style="font-size: 0.8rem">                                                        
                                <label class="checkbox" rv-if="col.datatype | eq 'checkbox'">
                                    <input type="checkbox" rv-checked="row._checked" rv-on-change="handleOnChange"/>
                                </label>
                                <!--<span rv-if="col.interactive" rv-class-tag="col.isId">
                                    <a rv-on-click="handleOnClick">{col.v}</a>
                                </span>-->
                                <span rv-unless="col.datatype | eq 'checkbox'" style="font-size: 0.9rem" rv-class-tag="col.isId" >{row | property col.key}</span>
                            </td>
                        </tr>
                        
                        
                        <tr class="is-hidden" rv-class-is-hidden="model._entities.list | sizeGte 1">
                            <td colspan="100">No items matching criteria</td>                    
                        </tr>
                    </tbody>
                    <tbody rv-unless="model.prop.editable" rv-data-x="reloadReadOnly | call model model.prop.columns model.prop.rows model.prop.value">                    
                        <!-- is-selected -->
                        <tr rv-each-row="model._entities.list">                                                
                            <td rv-each-col="model._columns" style="font-size: 0.8rem">                                                        
                                <label class="checkbox" rv-if="col.datatype | eq 'checkbox'">
                                    <input type="checkbox" rv-checked="row | property '_checked'"/>                                    
                                </label>
                                <!--<span rv-if="col.interactive" rv-class-tag="col.isId">
                                    <a rv-on-click="handleOnClick">{col.v}</a>
                                </span>-->
                                <span style="font-size: 0.9rem" rv-class-tag="col.isId" >{row | property col.key}</span>
                            </td>
                        </tr>
                        
                        
                        <tr class="is-hidden" rv-class-is-hidden="model._entities.list | sizeGte 1">
                            <td colspan="100">No items matching criteria</td>                    
                        </tr>
                    </tbody>
                </table>
            </div>
            `
            return template;
        },
      
        // Takes the original element and the data that was passed into the
        // component (either from rivets.init or the attributes on the component
        // element in the template).
        // prop.columns
        // [{
        //     label: "#", 
        //     key: "row property name", 
        //     datatype:"checkbox",
        //     isId: false
        // }]
        // prop.rows - array of objects
        // [{
        //     col1: "value",
        //     colx: "value"               
        // }]
        // for longer texts require class="has-tooltip-arrow has-tooltipl-multiline" data-tooltip="Multiline&#10;Content&#10;World!"
        // bulma-tooltip.min.css
        // also <script src="js/text-ellipsis.min.js"></script>
        // <link rel="stylesheet" href="assets/css/bulma-tooltip.min.css">
        initialize: function(el, data) {
            const controller = {
                model: {      
                    prop: data.prop, 
                    props: data.props, // for rules working
                    error: {
                        message: undefined
                    },                                                             
                    auth: data.auth,                    
                    _columns: [],
                    _entities: {
                        original: [],
                        list: [],
                        filter: ""
                    }    
                },  
                validate: function(){
                    let valid = true;
                    this.model.error.message = undefined;
                    if(this.model.prop.obligatory && !this.model.prop.value){
                        this.model.error.message = `${this.model.prop.label} must not be empty`;                        
                        valid = false;
                    }
                    
                    return valid;
                }, 
                handleOnChange: function(e,that){                                              
                    that.model.prop.value = that.model.prop.value ||"";                    

                    const idColumn = that.model._columns.find(item=>item.isId);

                    const ids = that.model._entities.original.filter(item=>item._checked).map(item=>item[idColumn.key]);                    

                    that.model.prop.value = ids.join(",");
                },
                  
                reload: async function(model, columns, rows){    
                    if(!rows || rows.length == 0) return;                                    
                    
                    model._entities.filter = ""

                    while(model._entities.original.length) {model._entities.original.pop()}
                    while(model._entities.list.length) {model._entities.list.pop()}
                    while(model._columns.length) {model._columns.pop()}   

                    if(model.prop.editable){
                        // find id column
                        const idColumn = columns.find(item=>item.isId);
                        model._columns.push({
                            // checkbox to select item                            
                                label: "#", 
                                key: idColumn.key, 
                                datatype:"checkbox",
                                isId: false                                                            
                        })                                                
                    }
                    columns.forEach(item=>model._columns.push(item));


                    rows.forEach(item=>{
                        item._checked = false;
                        model._entities.original.push(item)
                    });
                    rows.forEach(item=>{
                        item._checked = false;
                        model._entities.list.push(item)
                    });

                    
                },
                reloadReadOnly: async function(model, columns, rows, value){                                        
                    
                    model._entities.filter = ""

                    while(model._entities.original.length) {model._entities.original.pop()}
                    while(model._entities.list.length) {model._entities.list.pop()}
                    while(model._columns.length) {model._columns.pop()}   
                    
                    columns.forEach(item=>model._columns.push(item));

                    const ids = value.split(",").map(item=>item.trim());
                    if(ids[0]=="__all_rows"){
                        rows.forEach(item=>model._entities.original.push(item));
                        rows.forEach(item=>model._entities.list.push(item));
                    }else{
                        const idColumn = columns.find(item=>item.isId);
                        rows.find(row=>ids.includes(row.data[idColumn.key].v)).forEach(item=>{
                            model._entities.original.push(item);
                            model._entities.list.push(item)
                        })
                    }
                },
                handleSearch: async function(e, that){
                    await that._filter();
                },                
                async _filter(){                    
                    while(this.model._entities.list.length) {this.model._entities.list.pop()}                    

                    // JSON.parse(JSON.stringify(this.model._entities.original)).forEach(item=>{
                    this.model._entities.original.forEach(item=>{
                        if(this.model._entities.filter){
                            // const rowString = JSON.stringify(item).toLocaleLowerCase();
                            const rowString = Object.values(item).join(" ").toLocaleLowerCase();
                            if(rowString.includes(this.model._entities.filter.toLocaleLowerCase()))
                                this.model._entities.list.push(item);
                        }else{
                            this.model._entities.list.push(item);
                        } 
                    })
                }                
            }
            data.prop.validate = controller.validate.bind(controller);            
            return controller;
        }
    }
})();